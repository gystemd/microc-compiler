
\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{adjustbox}
\title{Microc report}
\author{Giulio Piva}
\date{November 2023}

\begin{document}

\maketitle


\section{Parser}
The following is the grammar of microc:
\begin{lstlisting}[language=C, basicstyle=\ttfamily\fontsize{8pt}{14pt}, keywordstyle=\color{blue}, commentstyle=\color{green}]
Program::= Topdecl* EOF

Topdecl::= Varlist; | Fundecl | Structdecl ";"

Varlist::= Typ Vardecl*

Vardecl::= Vardesc "=" Expr

Vardesc::= ID | "*" Vardesc | "(" Vardesc ")"
| Vardesc "[""]" | Vardesc "[" INT "]"

Fundecl::= Typ ID "(" ((decl",")* decl)? ")" Block

Structdecl::= "struct" ID "{" (decl";")* "}"

decl:: Typ Vardesc

Block::= "{" (Stmt | Vardecl ";" | Vardecl "=" Expr ";") "}"

Typ::= "int" | "char" | "void"
| "bool" | "float" | "struct" ID

Stmt::= "return" Expr ";" | Expr ";"
| Block | "while" "(" Expr ")" Stmt
| "for" "(" Expr? ";" Expr? ";" Expr? ")" Stmt
| "do" Stmt "while" "(" Expr ")" ";"
| "if" "(" Expr ")" Stmt "else" Stmt
| "if" "(" Expr ")" Stmt

Expr::= RExpr | LExpr

LExpr::= ID | "(" LExpr ")"
| "*" LExpr | "*" AExpr
| LExpr "[" Expr "]"
| LExpr "." ID

RExpr::= AExpr | "sizeof" "(" Expr ")"
| ID "(" ((Expr ",") Expr)? ")"
| LExpr "=" Expr| Lexpr Shortop Expr | "!" Expr
| "-" Expr | "~" Expr|Expr BinOp Expr| "++" Lexpr
| "--" Lexpr | Lexpr "++" | Lexpr "--"

Bin0p::= "+" | "-" | "*" | "%" | "/"
| "&&" | "||" | "<" |">""<=" | ">="
| "==" | "!=" | "&" | "|" | "^"| ">>" | "<<"

Shortop ::= "+=" | "-=" | "*=" | "/=" | "&="

AExpr ::= INT | CHAR | BOOL | FLOAT | STRING | "NULL"
| "(" RExpr ")" | "&" LExpr
\end{lstlisting}
It has been modified to accomodate the following features:
\begin{itemize}
    \item multiple variable declaration and initialization: multiple variables can be declared and initialized in a single statement
    like the following: \textbf{int a = 1, b = 2, c = 3;}. However, since function parameters and struct fields don't support initialization,
    two different rules have been created: varlist and genericparam. The first one is used for variable declarations,
    while the latter is used for declaring function parameters and struct fields.
    \item sizeof operator: sizeof is considered as operator and not as a function. As such, its name has been added to the list of reserved keywords.
    \item bitwise operators
    \item short assignment operators
    \item Struct declaration and access
    \item do-while loop
    \item String literals
    \item Floating point numbers
\end{itemize}
\subsection*{Grammar disambiguation}
\begin{itemize}
  \item dangling else: give precedence to if statement with an empty else branch
  \item Binary operators: inline the BinOp rule
  \item Bitwise operators
\end{itemize}

\section{Symbol Table}
The symbol table has been implemented as a list of hash tables to resemble a hierarchical scope structure.
Therefore, the head of the list represents the local scope, whereas the tail represents the global scope.
For convenience and efficiency, three different symbol tables have been created for storing information about variables, functions and structs.
Those three tables are then composed into a single object which is carried throughout the sematic analysis and code generation phases.
The type signature of a symbol list is the following:
\begin{lstlisting}
type 'a t = (string, 'a) Hashtbl.t list
\end{lstlisting}

The type signature of the context object is the following:
\begin{lstlisting}
type context = {
  fun_symbols : 'a Symbol_table.t;
  var_symbols : 'b Symbol_table.t;
  struct_symbols : 'c Symbol_table.t;
}
\end{lstlisting}

The type of context assumes different values during the semantic analysis and code generation phases, which will explained in the following sections.
\section{Semantic Analysis}
The aim of the semantic analysis of a microc program is to check the well-typedness of the program.
This phase recursively traverses the AST and checks that the statements of the programs satisfy the rules of the type system.
The relevant functions are the following:

\begin{itemize}
  \item \textbf{fundecl\_type\_check}
  \item \textbf{structdecl\_type\_check}
  \item \textbf{var\_type\_check}
  \item \textbf{stmt\_type\_check}
  \item \textbf{stmtordec\_type\_check}
\end{itemize}
All of these leverage the following other functions to obtain the type of their arguments and expressions:
\begin{itemize}
  \item \textbf{expr\_type}
  \item \textbf{access\_type}
  \item \textbf{unaryexp\_type}
  \item \textbf{binaryexp\_type}
\end{itemize}

\subsection{Semantic analysis Symbol Table}
The type signature of the symbol table for this phase is the following:

\begin{lstlisting}[basicstyle=\ttfamily\fontsize{6pt}{1em}]
type var_info = (code_pos * fun_decl) Symbol_table.t;
type fun_info = (code_pos * typ) Symbol_table.t;
type struct_info = (code_pos * struct_decl) Symbol_table.t;

type context = {
  fun_symbols : fun_info Symbol_table.t;
  var_symbols : var_info Symbol_table.t;
  struct_symbols : struct_info Symbol_table.t
}
\end{lstlisting}


\subsection{Additional rules}
\paragraph*{Type Unification}
   In certain cases, types should not be directly compared for equality, but rather checked for compatibility.
   The helper function \textbf{match\_types} is utilized to implement the following type checking rules:
  \begin{itemize}
    \item Variable Initialization and Assignment: Pointer variables can be assigned the value NULL.
    \item Function Parameter Types: Unsized arrays are permissible as function parameters, allowing declarations in the form of a[] or a[][2][2].
  \end{itemize}

\paragraph*{Global variable initialization}
Global variables can be initialized only with compile-time defined constants.

\paragraph*{String initialization}
Strings are implemented as arrays of characters, but arrays cannot neither be initialized nor assigned in microc.
Therefore, a special case has been added when checking the declaration of an array of characters to allow string declarations.
The function which handles string initialization is \textbf{init\_string}.

\paragraph*{Independent-order declarations}
Functions and structs can be declared in any sequence and utilized prior to their declaration.
This necessitates an initial scan of the program to incorporate the signatures into the symbol table.
The bodies of these functions and structs are then verified in a subsequent scan.

\paragraph*{deadcode detection}
Various types of dead code exist. In this project, I focused on detecting code that follows a return statement.
To facilitate this analysis, a boolean flag was incorporated into the return types of the \textbf{stmt\_type\_check}
and \textbf{stmtordec\_type\_check} functions. This flag indicates whether the scan should proceed, specifically if
a return statement has been encountered. If instructions are found after a return statement, an exception is raised.

\paragraph*{Runtime support functions}


\section{Code Generation}
The code generation phase is responsible for generating the LLVM bitcode of the program.
As before, the code generation phase recursively traverses the AST and generates the bitcode for each statement, mapping
them to the corresponding LLVM operation.
The relevant functions are the following:
\begin{itemize}
  \item \textbf{codegen\_fundecl}: maps a function declaration to a LLVM function
  \item \textbf{codegen\_structdecl}:
  \item \textbf{codegen\_stmt}: maps a statement to its corresponding LLVM operation.
  In particular if,while and do-while statements are mapped according to
  the following templates: \\
  \textbf{if statement}: \\

\begin{minipage}{0.20\textwidth}
\begin{verbatim}
  if(cond) {
    ...
  }
  else {
    ...
  }
  <remaining code>
\end{verbatim}
\end{minipage}
\hspace{1cm} $\rightarrow$ \hspace{0.5cm}
\begin{minipage}{0.45\textwidth}
\begin{verbatim}
br <cond>, label %then, label %else
then:
  ; then body
else:
  ; else body
  br label %cont
cont:
  ; remaining code
\end{verbatim}
\end{minipage}


%while
\textbf{while statement}: \\

\begin{minipage}{0.20\textwidth}
\begin{verbatim}
  while(cond) {
    ...
  }
  <remaining code>
\end{verbatim}
\end{minipage}
\hspace{1cm} $\rightarrow$ \hspace{0.5cm}
\begin{minipage}{0.45\textwidth}
\begin{verbatim}
br label %test
test:
  ; necessary code to evaluate cond
  br <cond>, label %body, label %cont

body:
  ; while body
  br label %test

cont:
  ; remaining code

\end{verbatim}
\end{minipage}

%do-while
% \textbf{do-while statement}: \\

% \begin{minipage}{0.20\textwidth}
% \begin{verbatim}
%   while(cond) {
%     ...
%   }
%   <remaining code>
% \end{verbatim}
% \end{minipage}
% \hspace{1cm} $\rightarrow$ \hspace{0.5cm}
% \begin{minipage}{0.45\textwidth}
% \begin{verbatim}
% br label %test
% test:
%   ; necessary code to evaluate cond
%   br <cond>, label %body, label %cont

% body:
%   ; while body
%   br label %test

% cont:
%   ; remaining code

% \end{verbatim}
% \end{minipage}
  \item \textbf{codegen\_access}: maps each variable, pointer and array access to the associated address in memory
  \item \textbf{codegen\_un\_op}
  \item \textbf{codegen\_bin\_op}
\end{itemize}

\subsection*{Code generation Symbol Table}
\begin{lstlisting}
type context =
  { fun_symbols : L.llvalue Symbol_table.t
  ; var_symbols : L.llvalue Symbol_table.t
  ; struct_symbols : (L.lltype * string list) Symbol_table.t
  }
\end{lstlisting}

\subsection*{Struct and Function generation}
Similar to the semantic analysis, structs are generated in advance to
permit their use before declaration. However, in this case, the structs
are fully generated, not just their signatures.
This is necessary because when accessing a field of a struct object,
an address must exist in LLVM. Conversely, for function declarations,
generating only the signature is sufficient to enable its invocation.

\subsection*{Array parameters}
Array parameters are converted to pointers. This was done either to resemble the C language practice
and to support the unsized array as parameter.
However this mechanism introduces some additional checks when accessing an array in the code.
For instance, let's consider the following code:
\begin{lstlisting}[basicstyle=\ttfamily\fontsize{8pt}{14pt}, keywordstyle=\color{blue}, commentstyle=\color{green}]
int foo(int a[]) {
  int b[2];
  b = a[0];
  return b;
}
\end{lstlisting}
At llvm level, \textbf{a} will have a pointer as type, whereas \textbf{b} will array type.
Therefore, when accessing an array, the two cases must be handled accordingly.
\end{document}

\subsection*{Global variable initialization}
Since global variables can only be initialized with compile-time defined constants, operations on these variables are restricted to constants.