
\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{adjustbox}
\title{Microc report}
\author{Giulio Piva}
\date{November 2023}

\begin{document}

\maketitle

\paragraph{Instructions for compiling and running tests}
To compile a microc program, you can run the script:

\begin{lstlisting}[frame=single,language=bash, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
chmod +x test_program.sh
test_program.sh <microc_file>
\end{lstlisting}
To run a suite of tests, you can run the script:
\begin{lstlisting}[frame=single, language=bash, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
chmod +x test_all.sh
test_all.sh <test_folder>
\end{lstlisting}

\section{Frontend}
The frontend of the compiler is responsible for parsing the input program and generating the AST.
It has been implemented using the Menhir parser generator and the ocamllex lexer generator.
ocammllex uses regular expressions to define the patterns for recognizing tokens in the source code.
Menhir, on the other hand, processes the stream of tokens produced by the lexer and
constructs an abstract syntax tree by means of code snippets associated with each grammar rule.
These two components are then combined into a parser engine in the file \textbf{parsing.ml}, used to parse the input program.


\subsection{Grammar}
The following is the grammar of microc:
\begin{lstlisting}[language=C, basicstyle=\ttfamily\fontsize{8pt}{14pt}, keywordstyle=\color{blue}, commentstyle=\color{green}]
Program::= Topdecl* EOF

Topdecl::= Varlist ";" | Fundecl | Structdecl ";"

Varlist::= Typ Vardecl*

Vardecl::= Vardesc "=" Expr

Vardesc::= ID | "*" Vardesc | "(" Vardesc ")"
| Vardesc "[""]" | Vardesc "[" INT "]"

Fundecl::= Typ ID "(" ((decl",")* decl)? ")" Block

Structdecl::= "struct" ID "{" (decl";")* "}"

decl:: Typ Vardesc

Block::= "{" (Stmt | Vardecl ";" | Vardecl "=" Expr ";") "}"

Typ::= "int" | "char" | "void"
| "bool" | "float" | "struct" ID

Stmt::= "return" Expr ";" | Expr ";"
| Block | "while" "(" Expr ")" Stmt
| "for" "(" Expr? ";" Expr? ";" Expr? ")" Stmt
| "do" Stmt "while" "(" Expr ")" ";"
| "if" "(" Expr ")" Stmt "else" Stmt
| "if" "(" Expr ")" Stmt

Expr::= RExpr | LExpr

LExpr::= ID | "(" LExpr ")"
| "*" "&" LExpr
| "*" LExpr | "*" AExpr
| LExpr "[" Expr "]"
| LExpr "." ID

RExpr::= AExpr | "sizeof" "(" Expr ")"
| ID "(" ((Expr ",") Expr)? ")"
| LExpr "=" Expr| Lexpr Shortop Expr | "!" Expr
| "-" Expr | "~" Expr|Expr BinOp Expr| "++" Lexpr
| "--" Lexpr | Lexpr "++" | Lexpr "--"

Bin0p::= "+" | "-" | "*" | "%" | "/"
| "&&" | "||" | "<" |">""<=" | ">="
| "==" | "!=" | "&" | "|" | "^"| ">>" | "<<"

Shortop ::= "+=" | "-=" | "*=" | "/=" | "&="

AExpr ::= INT | CHAR | BOOL | FLOAT | STRING | "NULL"
| "(" RExpr ")" | "&" LExpr
\end{lstlisting}
As specified before, each time a rule is matched, a node of the AST is created. See the file \textbf{parserm.mly} for more information.
\subsection{Grammar modifications}
In relation to the original grammar provided by the assignment, the following modifications
have been implemented to extend the language:
\begin{itemize}
    \item multiple variable declaration and initialization: multiple variables can be declared and initialized in a single statement
    like the following: \textbf{int a = 1, b = 2, c = 3;}. However, since function parameters and struct fields don't support initialization,
    two different rules have been created: varlist and decl. The first one is used for variable declarations,
    while the latter is used for declaring function parameters and struct fields.
    \item sizeof operator: sizeof is considered as operator and not as a function. As such, its name has been added to the list of reserved keywords.
    \item bitwise operators: $<<$, $>>$, \&, $|$ , \^{} have been added to the list of binary operators.
    \item multi-dimensional arrays.
    \item short assignment operators: +=, -=, *=, \%=.
    \item struct declaration and access: structs can be declared and accessed using the dot operator. The struct declaration must end with a semicolon.
    \item do-while loops.
    \item string literals: implemented as arrays of characters.
    \item floating point numbers:
\end{itemize}
\subsection{Grammar disambiguation}
The raw form of this grammar is ambiguous.
To resolve this, Menhir's precedence and associativity rules have been utilized for disambiguation:
\begin{itemize}
  \item dangling else: give precedence to if statement with an empty else branch
  \item Binary operators: inline the BinOp rule
  \item Bitwise operators: give precedence to bitwise operators over logical operators
\end{itemize}

\section{Symbol Table}
The symbol table has been implemented as a list of hash tables to resemble a hierarchical scope structure.
Therefore, the head of the list represents the local scope, whereas the tail represents the global scope.
For convenience and efficiency, three different symbol tables have been created for storing information about variables, functions and structs.
Those three tables are then composed into a single object which is carried throughout the sematic analysis and code generation phases.
The type signature of a symbol list is the following:
\begin{lstlisting}[linewidth=10cm, frame=single, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
type 'a t = (string, 'a) Hashtbl.t list
\end{lstlisting}
The type signature of the agglomerating object is the following:
\begin{lstlisting}[linewidth=10cm, frame=single, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
type environment = {
  fun_symbols : 'a Symbol_table.t;
  var_symbols : 'b Symbol_table.t;
  struct_symbols : 'c Symbol_table.t;
}
\end{lstlisting}
The types will assumes different values during the semantic analysis and code generation phases, which will explained in the following sections.
\section{Semantic Analysis}
The aim of the semantic analysis of a microc program is to check the well-typedness of the program.
This phase recursively traverses the AST and checks that the statements of the programs satisfy the rules of the type system.
The relevant functions are the following:

\begin{itemize}
  \item \textbf{fundecl\_type\_check}
  \item \textbf{structdecl\_type\_check}
  \item \textbf{var\_type\_check}
  \item \textbf{stmt\_type\_check}
  \item \textbf{stmtordec\_type\_check}
\end{itemize}
All of these leverage the following other functions to obtain the type of their arguments and expressions:
\begin{itemize}
  \item \textbf{expr\_type}
  \item \textbf{access\_type}
  \item \textbf{unaryexp\_type}
  \item \textbf{binaryexp\_type}
\end{itemize}

\subsection{Semantic analysis Symbol Table}
The type signature of the symbol table for this phase is the following:

\begin{lstlisting}[linewidth=13cm, frame=single, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
type var_info = (code_pos * fun_decl) Symbol_table.t;
type fun_info = (code_pos * typ) Symbol_table.t;
type struct_info = (code_pos * struct_decl) Symbol_table.t;

type environment= {
  fun_symbols : fun_info Symbol_table.t;
  var_symbols : var_info Symbol_table.t;
  struct_symbols : struct_info Symbol_table.t
}
\end{lstlisting}
for each kind of symbol, different information are stored and used during the analysis:
\begin{itemize}
  \item \textbf{var\_info}: the type of the variable
  \item \textbf{fun\_info}: The return and parameter types of the function
  \item \textbf{struct\_info}: The fields of the struct along with their types
\end{itemize}


\subsection{Additional rules}
\paragraph*{Type Unification}
   In certain cases, types should not be directly compared for equality, but rather checked for compatibility.
   The helper function \textbf{compare\_types} is utilized to implement the following type checking rules:
  \begin{itemize}
    \item Variable Initialization and Assignment: Pointer variables can be assigned the value NULL.
    \item Function Parameter Types: Unsized arrays are permissible as function parameters, allowing declarations in the form of a[] or a[][2][2].
  \end{itemize}

\paragraph*{Global variable initialization}
Global variables can be initialized only with compile-time defined constants. In microc, this means that
they cannot be initialied with a function call.

\paragraph*{Underflow and Overflow}
When assigning a value or initializing a variable, the value must be within the range of the type.

\paragraph*{String initialization}
Strings are implemented as arrays of characters, but arrays cannot neither be initialized nor assigned in microc.
Therefore, a special case has been added when checking the declaration of an array of characters to allow string declarations.
The function which handles string initialization is \textbf{init\_string}.


\paragraph*{Deadcode detection}
Various types of dead code analyses exist. In this project, I focused on detecting code that follows a return statement.
To facilitate this analysis, a boolean flag was incorporated into the return types of the \textbf{stmt\_type\_check}
and \textbf{stmtordec\_type\_check} functions. This flag indicates whether the scan should proceed, specifically if
a return statement has been encountered. If instructions are found after a return statement, an exception is raised.

\paragraph*{Independent-order declarations}
Functions and structs can be declared in any sequence and utilized prior to their declaration.
This necessitates an initial scan of the program to incorporate the signatures into the symbol table.
The bodies of these functions and structs are then verified in a subsequent scan.

\paragraph*{Runtime support functions}
During the initial scan, runtime support functions are incorporated into the symbol table.
These runtime functions are defined in the \textbf{runtime.c} file.
For each function, a placeholder AST node with an empty body is created
and added to the symbol table.
Most of the runtime functions are used to input and output data.
Their implementation will be linked to the produced bitcode by Clang.

\section{Code Generation}
The code generation phase is responsible for generating the LLVM bitcode of the program.
As before, the code generation phase recursively traverses the AST and generates the bitcode for each statement, mapping
them to the corresponding LLVM operation.
The relevant functions are the following:
\begin{itemize}
  \item \textbf{codegen\_fundecl}: maps a function declaration to a LLVM function.
  It generates the body of the function and adds a default terminator if a return statement is not present.
  \item \textbf{codegen\_struct}: maps a struct declaration to a "named structure" in LLVM
  \item \textbf{codegen\_stmt}: maps a statement to its corresponding LLVM operation.
  In particular if,while and do-while statements are mapped according to
  the following templates: \\
  \textbf{if statement}: \\

\begin{minipage}{0.20\textwidth}
\begin{verbatim}
  if(cond) {
    ...
  }
  else {
    ...
  }
  <remaining code>
\end{verbatim}
\end{minipage}
\hspace{1cm} $\rightarrow$ \hspace{0.5cm}
\begin{minipage}{0.45\textwidth}
\begin{verbatim}
br <cond>, label %then, label %else
then:
  ; then body
  br label %cont
else:
  ; else body
  br label %cont
cont:
  ; remaining code
\end{verbatim}
\end{minipage}


%while
\textbf{while statement}: \\

\begin{minipage}{0.20\textwidth}
\begin{verbatim}
  while(cond) {
    ...
  }
  <remaining code>
\end{verbatim}
\end{minipage}
\hspace{1cm} $\rightarrow$ \hspace{0.5cm}
\begin{minipage}{0.45\textwidth}
\begin{verbatim}
br label %test
test:
  ; necessary code to evaluate cond
  br <cond>, label %body, label %cont

body:
  ; while body
  br label %test

cont:
  ; remaining code

\end{verbatim}
\end{minipage}

%do-while
% \textbf{do-while statement}: \\

% \begin{minipage}{0.20\textwidth}
% \begin{verbatim}
%   while(cond) {
%     ...
%   }
%   <remaining code>
% \end{verbatim}
% \end{minipage}
% \hspace{1cm} $\rightarrow$ \hspace{0.5cm}
% \begin{minipage}{0.45\textwidth}
% \begin{verbatim}
% br label %test
% test:
%   ; necessary code to evaluate cond
%   br <cond>, label %body, label %cont

% body:
%   ; while body
%   br label %test

% cont:
%   ; remaining code

% \end{verbatim}
% \end{minipage}
  \item \textbf{codegen\_access}: maps each variable, pointer and array access to the associated address in memory.
  \item \textbf{codegen\_expr}: maps each expression to the corresponding intermediate representation. It loads
  values returned by \textbf{codegen\_access}.
\end{itemize}

\subsection*{Code generation Symbol Table}
\begin{lstlisting}[linewidth=13.5cm, frame=single, basicstyle=\ttfamily\fontsize{8pt}{14pt}]
type environment=
  { fun_symbols : L.llvalue Symbol_table.t
  ; var_symbols : L.llvalue Symbol_table.t
  ; struct_symbols : (L.lltype * string list) Symbol_table.t
  }
\end{lstlisting}
for var\_symbols and fun\_symbols, an llvalue is stored, which is their corresponding LLVM implementation.
For struct\_symbols, a tuple of an lltype and a list of strings. The latter element is required because, once a struct is declared,
fields name will be forgotten.


\subsection*{Struct and Function generation}
Similar to the semantic analysis, structs are generated in advance to
permit their use before declaration. However, in this case, the structs
are fully generated, not just their signatures.
This is necessary because when accessing a field of a struct object,
an address must exist in LLVM. Conversely, for function declarations,
generating only the signature is sufficient to enable its invocation.

\subsection*{Array parameters}
Array parameters are converted to pointers, mirroring the practice in the C language
This mechanism allows the use of unsized arrays as parameters.
However, this conversion necessitates additional checks when accessing an array in the code.
Consider the following example:
\begin{lstlisting}[basicstyle=\ttfamily\fontsize{8pt}{14pt}, keywordstyle=\color{blue}, commentstyle=\color{green}]
int foo(int a[]) {
  int b[2];
  b[0] = a[0];
  ...
}
\end{lstlisting}
In the produced LLVM bitcode, \textbf{a} is of pointer type, while \textbf{b} is of array type. Therefore, array access must be handled differently when
the code generator encounters a AccIndex expression.
Function calls must also accommodate this conversion. Upon encountering a Call statement,
the code generator will pass a pointer to the array's first element as the argument.
\end{document}

\subsection*{Global variable initialization}
Since global variables can only be initialized with compile-time defined constants, operations on these variables are restricted to constants.